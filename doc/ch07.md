# 모듈을 사용하여 코드를 재사용하고 조직화하기(Managing Growing Projects with Packages, Crates, and Modules)

큰 프로그램을 작성하면서, 여러분의 코드를 정리하는(organizing) 것은 중요하다. 왜냐하면 여러분의 전체 프로그램을 머릿속에서 추적하는 것은 불가능할 것이기 때문이다. '기능적으로 관련성(functionality)'이 있는 것은 묶고, 상이한 특징(feature)을 가지고 있는 코드는 분리하면서, 여러분은 특정한 특징을 제공하는(implement) 코드가 어디있는지, 그리고 특정 특징이 작동하는 방법을 바꾸기 위해서 어디로 가야 하는지를 명확히 할 것입니다(By grouping related functionality and separating code with distinct features, you’ll clarify where to find code that implements a particular feature and where to go to change how a feature works).

. 패키지가 커감에 따라, 여러분은 외부적으로 '종속 관계(dependencie)'가 될 독립적인(separate) 크레이트로 추출할 수 있다. 이 장에서는 이런 모든 테크닉을 다룰 것이다. '함께 진화하는(evolve together)' '서로 관계가 있는(interrelated)' 패키지들의 집합인 매우 큰 프로젝트를 위해서, 카고(Cargo)는 '작업 공간(workspaces)'을 제공하는데, 이는 우리가 14장 “카고 작업 공간(Cargo Workspaces)”이라는 절(section)에서 다를 것이다.

'기능적으로 관련성(functionality)'이 있는 것은 묶는 것에 추가하여, '캡슐로 싸서 구현하는 항목들(encapsulating implementation details)'은 여러분에게 더 높은 단계의 코드 재사용(reuse)을 할 수 있게 해준다: 여러분이 한 번 기능(operation)을 구현해 놓으면, 다른 코드는 이 코드를 어떻게 구현되서 작동하는지 알 필요 없이 그 코드의 공개(public) 인터페이스(interface)를 통해 그 코드를 호출할 수 있다. 여러분이 코드를 작성하는 방법은 다른 코드가 사용하기 위해서 공개한 부분들과 여러분이 변경할 권리를 보유하려는 비공개(private)로 '구현하는 항목들(implementation details)'인 부분으로 정의한다(defines). 이는 여러분이 '머릿속에 명심해야 할(have to keep in your head)' '항목들의 양(the amount of detail)'을 제한해줄 또 다른 방법이다.

관련된 개념은 범위(scope)이다: 코드가 쓰여진 중첩된(nested) 문맥(context)은 "범위 안(in scope)"이라고 정의된 이름들의 집합을 가지고 있다(the nested context in which code is written has a set of names that are defined as “in scope.”). 코드를 읽고, 쓰고 컴파일할 때, 프로그래머나 컴파일러는 '특정 지점(particular spot)'에서  개별적인(particular) 이름이 변수, 함수, 구조체, 열거형, 모듈, 상수, 또는 또다른 항목(item)을 참조(refers)하는지 안 하는지 그리고 그 항목이 의미하는 것이 무엇인지 알 필요가 있다. 여러분은 범위를 창조할 수 있고, 이름들이 그 범위 안에 있는지 또는 그 범위 밖에 있는지를 변경할 수 있다. 여러분은 같은 범위 안에서 같은 이름을 가진 2개의 항목을 가질 수 없다; (물론) 이름 충돌(conflicts)을 해결할 수 있는 도구들(tools)을 이용할 수 있다.

코드 몇줄을 함수로 추출하는 것과 같은 방식으로, 여러분은 함수 (혹은 구조체나 열거형 같은 다른 코드들)를 다른 모듈로 뽑아낼 수 있으며, 여러분은 이것들의 정의가 모듈의 바깥쪽에서 볼 수 있도록 하거나(public) 혹은 보이지 않게 하도록(private) 선택할 수 있습니다. 모듈이 어떤 식으로 동작하는지에 대한 개요를 봅시다:

러스트는 여러분들이 여러분의 코드 구성(organization)을 관리하기 위한 몇 가지 특징들(features)을 가지고 있는데, 이 특징들은 세부항목들(details)을 공개(exposed)하거나, 세부항목들을 비공개로(private) 하거나, 그리고 여러분의 포르그램 안 각각의 범위 안에 있는 어떤 이름들이 있는지를 포함한다.이러한 특징들은, 때대로 '모듈 시스템(module system)'과 같이 일괄적으로(collectively) 적용한 것처럼, 다음과 같이 포함된다:

- **패키지(Packages)**: 여러분이 크래이트를 빌트하고, 테스트하고 그리고 공유할 수 있게 해주는 카고의 특징(feature)
- **크레이트(Crates)**: 라이브러리나 '실행 파일(executable)'을 생성하는 모듈들의 가계도(tree)
- **모듈(Modules)** 그리고 **use**: 여러분들이 구성, 범위 그리고 경로들의 '공개 또는 비공개(privacy)'을 조절할 수 있도록 해 준다.
- **경로(Paths)**: 구조체, 함수 또는 모듈과 같은 항목(item)의 이름을 지어주는 방법

이번 장에서는 이런 것을 살펴보고, 범위를 관리하기 위해서 이것들을 사용하는 방법을 설명할 것이다.

## 패키지와 크레이트(Packages and Crates)

크래이트는 바이너리 또는 라이브러리이다(A crate is a binary or library). 패키지는 기능적으로 관련성이 있는 집합을 제공하는 하나 이상의 크레이트이다(A package is one or more crates that provide a set of functionality). 패키지는 `Cargo.toml`이라는 파일을 포함하고 있으며, 이 파일에는 패키지 안에 있는 하나 이상의 크레이트를 빌드하는 방법이 써있다.

`cargo new`이라는 명령어로 패키지를 생성할 때 어떤 일이 발생하는지 살펴보자.

```bash
cargo new my-project
```

생성한 다음 다음과 같이 무엇이 변했는지 살펴보자.

```bash
❯ cd my-project 
❯ ls
Cargo.toml src
❯ cd src 
❯ ls
main.rs
```

앞에서 살펴본 것처럼 `cargo new`를 실행하면 `Cargo.toml`를 생성하고 우리에게 어떤 패키지를 제공한다. 이 파일의 내용을 살펴보면, `src/main.rs`에 대한 아무런 언급도 없는데, 왜냐하면 카고(cargo)는 `src/main.rs`이 그 패키키와 같은 이름을 갖는 '바이너리 크레이트(binary crate)'의 크레이트 루트(root)라는 관례(convention)를 따르기 때문이다. 마찬가지로 만약 패키지 디렉토리에 `src/lib.rs`를 가지고 있다면, 그 패키지와 같은 이름을 갖는 '라이브러리 크레이트(library crate)'를 가지고 있다면, `src/lib.rs`이 크레이트 루트라고 인식한다. 카고는 라이브러리나 파이너리를 빌트할 때, `rustc`에게 크레이트 루트 파일들을 전달한다.

앞의 경우에서는 `src/main.rs` 파일만 가지고 있기 때문에, 이 패키지는 `my-project`이라는 이름의 '바이너리 크레이트(binary crate)'만 포함하고 있는 셈이다. 만약 여기서 `src/main.rs` 과 `src/lib.rs`을 모두 가지고 있다면, 이는 라이브러리 크레이트와 바이너리 크레이트를 모두 가지고 있다는 뜻이며, 이 두 크레이트 모두 이름이 패키지 이름과 같게 된다. 패키지는 `src/bin`라는 디렉토리에 파일 여러 개를 놓아서 다중 바이너리 크레이트를 가질 수 있으며, 이때 각각의 파일은 독립된(separate) 바이너리 크레이트가 될 것이다.

특정 크레이트의 '기능적으로 관련성(functionality)'을 그 자신의 범위에서 유지한다는 것은 특정 '기능적으로 관련성(functionality)'을 우리 크레이트 안에서 또는 `rand` 크레이트안에서 정의한다 또는

Keeping a crate’s functionality in its own scope clarifies whether particular functionality is defined in our crate or the rand crate and prevents potential conflicts.

예를 들어, `rand` 크레이트는 `Rng`이라는 이름의 트레이트(trait)가 제공한다. 우리는 또한 우리 자신의 크레이트안에서 `Rng`이라는 이름의 `struct`(구조체)를 정의할 수 있다. 왜냐하면 크레이트의 '기능적으로 관련성(functionality)'은 그 자신의 범위 안에서 '이름 공간이 되기 (is namespaced)'때문에, 우리가 `rand`을 의존성(dependency)(편집자 주: 항목)에 추가할 때, 컴파일러는 `Rng`이라는 이름으로 참조한 것과 혼동하지 않는다(Because a crate’s functionality is namespaced in its own scope, when we add `rand` as a dependency, the compiler isn’t confused about what the name `Rng` refers to). 우리 크레이트 안에서, 컴파일러는 우리가 정의한 `struct Rng`을 참조한다. 우리는 `Rng` 트레이트를 `rand::Rng`에서 `rand`이라는 크레이트로부터 접근할 것이다(We would access the `Rng` trait from the `rand` crate as `rand::Rng`).

이제 모듈 시스템을 살펴보자.

## 공개 또는 비공개와 범위을 조절하여 모듈 정의하기(Defining Modules to Control Scope and Privacy)

우리는 **경로(paths)**를 통해서 항목(items)에 이름을 부여한다. 말하자면 `use` 키워드는 경로(path)를 범위에 이르게 한다. 그리고 `pub` 키워드는 항목(items)을 공개하게(public) 특정 크레이트는 특정 범위 안에서 '기능적으로 관련성(functionality)'으로 관계가 있는 것들을 무리로 만들었기에 그 '기능적으로 관련성(functionality)'은 다수의 프로젝트 사이에서 공유하기 쉽다(A crate will group related functionality together in a scope so 우리가 작성한 프로그램은 지금까지 한 개의 파일 안에 한 개의 모듈(module) 안에 있었다. 프로젝트가 커감에 따라, 여러분은 여러 개의 모듈들 그리고 여러 개의 파일들로 쪼개며 코드를 정리해야 한다. 패키지(package)는 여러개의 바이너리 크레이트와 선택적으로(optionally) 라이브러리 크레이트 한 개를 포함할 수 있다the functionality is easy to share between multiple projects). 예를 들어, 2장에서 사용했던 `rand`라는 크레이트는 랜덤(random) 숫자들을 생성하는(generates) '기능적으로 관련성(functionality)'이 제공했다. 우리는 `rand` 크레이트를 프로젝트 범위 안으로 가져와서 우리 자신의 프로젝트 안에서 그 '기능적으로 관련성(functionality)'을 사용할 수 있다. `rand` 크레이트에 의해서 제공된 모든 '기능적으로 관련성(functionality)'은 그 크레이트의 이름인, `rand`으로 사용할 수 있게 된다.
만든다. 우리는 `as` 키워드, 외부 패키지 그리고 '작은 방울(glob)' 연산자에 대해 논의할 것이다.

우리는 모듈을 가지고 코드를 크레이트 안에 정리해서 읽기 쉽고 재사용하기 쉽게 '무리로 만든다(groups)'. 또한 모듈로 항목(items)을 공개할지 안 할지 통제하는데, 이는 항목(items)을 외부 코드에서 사용할 수 있는지 (공개(public)) 또는 내부 '구현하는 항목들(implementation details)이고 외부 사용이 불가능한지(비공개(private))를 모듈로 통제한다.

레스토랑의 기능을 제공하는 `restaurant`라는 새로운 라이브러리 크레이트를 만들어 보자. 레스토랑은 손님들이 있는 부분인 ‘접객 부분(front of house)’과 ‘지원 부분(back of house)’으로 나눌 수 있다. 여기서 접객 부분은 점원들이 손님을 맞고, 앉히고, 주문을 받고, 음식값을 결재를 하며, 바텐더가 음료도 만드는 곳이다. 지원 부분은 셰프들와 요리사들이 주방에서 일하는 곳과 설거지를 하고, 메니저들이 관리 업무를 하는 곳이다. 우선 `restaurant`이라는 이름으로 라이브러리를 생성하자. 다음과 같이 하면 된다.

```bash
cargo new --lib restaurant
```

이렇게 만들어진 라이브러리는 지금까지 만든 것과는  다르게 `lib.rs`이라는 파일이 생겼다.

```bash
❯ ls
Cargo.toml src
❯ cd src
❯ ls
lib.rs
```

`lib.rs`에 다음 내용을 추가하자. 접객 시설인 `front_of_house`을 우선 만들고 그 안에 손님이 매장에 오면 할 `hosting` 부분과 손님이 매장에 들어와 테이블에 착석한 다음 할 `serving` 부분으로 나눴다.

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {
            println!("손님을 대기 명단에 추가합니다.");
        }

        fn seat_at_table() {
            println!("손님을 테이블로 모신 다음 앉힙니다.");
        }
    }

    mod serving {
        fn take_order() {
            println!("주문을 받습니다.");
        }

        fn serve_order() {
            println!("주문을 받습니다.");
        }

        fn take_payment() {
            println!("음식값을 지불하다.");
        }
    }
}
```

위의 예제 코드를 살펴보자. 우선 `mod` 키워드를 이용하여 모듈의 이름을 지정했다. 이 모듈에 속하는 부분은 `{}`으로 감싼다. 모듈 안에 다른 모듈을 정의할 수 있다. 그래서 위에서는 `mod`을 이용하여, `front_of_house`과 `serving`이라는 모듈을 지정했다. 모듈에는 다른 항목들, 예를 들어 구조체(structs), 열거자(enums), 상수(constants), 크레이트(traits), 그리고 앞에서처럼 함수(unctions)를 추가할 수 있다.

이처럼 모듈을 이용하면 관련된(related) 정의들(definitions)을 그룹으로 묶을 수 있다. 이렇게 되면 프로그래머들이 전체를 다 살펴보지 않아도 원하는 그룹 단위로 살펴보면서 필요한 것을 찾을 수 있게 해준다.

앞에서 `src/main.rs`와 `src/lib.rs`은 `크레이트 루트(crate roots)`라고 했었다. 이건 우리가 컴퓨터에서 사용하는 파일 시스템인 디렉토리와 유사하다.