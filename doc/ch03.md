# 러스트 프로그래밍 정리 - 일반적인 프로그래밍 개념

러스트 프로그래밍에서 사용하는 프로그래밍 개념에 대해 정리합니다.

## 변수와 가변성

변수는 `let mut` 을 사용해 선언할 수 있다. 만약 `mut`을 사용하지 않는다면, 러스트 프로그래밍은 기본적으로 불변형 변수로 간주한다. 예를 들면 아래와 같은 코드는 컴파일 에러를 일으킨다.

```rust
fn main() {
    let x = 5;
    println!("x의 값: {}", x);
    x = 6;
    println!("x의 값: {}", x);
}
```

에러 화면은 다음과 같다.

```bash
cargo run

error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!("x의 값: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
error: could not compile `programming_concept`

To learn more, run the command again with --verbose.

```

에러의 원인은 불변형 변수로 선언한 x에 새로운 값을 할당하려 했기 때문이다. 값을 두번 할당하려면, 코드를 다음과 같이 변경해주면 된다. 아래 코드는 컴파일 에러를 발생시키지 않는다. x에 `mut`를 붙여 가변 변수로 만들었기 때문이다.

```rust
fn main() {
    let mut x = 5;
    println!("x의 값: {}", x);
    x = 6;
    println!("x의 값: {}", x);
}
```

### 변수와 상수의 차이점

불변 변수와 상수는 차이가 있다. 상수는 항상 불변이다. 즉 `mut` 키워드를 사용할 수 없다. 상수는 `const`를 사용해 선언한다. 상수를 선언할 때는 반드시 값의 타입에 대해 지정해주어야 한다. 상수는 호출 결과나 런타임에만 계산할 수 있는 다른 값 예를 들면 함수호출 결과 같은 것이 아닌 반드시 상수 표현식으로만 설정할 수 있다. 아래는 상수 선언 예이다.

`const MAX_POINTS: u32 = 100_000;`

러스트의 프로그래밍 관례로 상수 작성시 언더 바(_)를 가독성을 위해 사용할 수 있다.

### 변수 가리기(shadow)

러스트 프로그래밍에서도 변수를 덮어쓸 수 있다. 새 변수의 이름을 이전 변수의 이름과 똑같이 선언할 수 있고 그러면, 새 변수는 이전 변수를 덮어쓰게 된다. 예를 들면 `let x = 5;`, `let x = x + 1;`, `let x = x * 2;` 이런 식이다. 이때 첫 번째 변수가 두 번째 변수에 의해 가려졌다(shadowed)라 표현한다.

아무리 가변형 변수를 `mut`으로 설정해도 `let` 키워드 없이 변수를 재할당 하려면 컴파일-타임 에러가 발생한다. `let` 키워드 사용시 값을 변경하면서 불변형을 유지할 수 있다. `let`을 이용한 덮어쓰기와 `mut`으로 가변형 변수를 만들 때 차이점은 덮어쓰기의 경우 다른 타입의 데이터를 덮어쓸 수도 있다는 점이다.

## 데이터 타입

러스트에서 사용되는 모든 값은 그 값의 데이터 타입을 가진다. 크게 두 가지로 나눌 수 있는데 스칼라 타입과 복합 타입(Compound)이다. 러스트는 정적 언어로서 컴파일 시점에 모든 변수들의 타입이 정해져 있어야 한다.

### 스칼라 타입

먼저 러스트의 스칼라 타입은 정수, 부동 소수점 숫자, boolean, 그리고 문자, 이렇게 네 가지가 있다.
아래의 표는 정수형 타입 표이다.

| 크기  | 부호 있음  | 부호 없음 |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |

정수형은 u32로 32비트 정수형을 의미하며, 만약 부호가 있다면 u 대신 i를 사용한다. 즉 음수의 경우 u가 아닌 i로 선언되어야 한다. 정수 형태는 각 비트 수에 따라 8, 16, 32, 64, 128까지 있다. 비트 수에 따라 달라지는 점은 포괄할 수 있는 수의 범위가 달라진다. 만약 i 형태라면 -(2^(n - 1)) 부터 (2^(n - 1) - 1) 까지 n은 비트의 수이다. u의 형태는 부호가 없기에 0 부터 (2^(n - 1) - 1)까지 포괄한다. 만약 포괄 범위 이상의 정수를 선언하려하면 정수 오버플로우 문제가 발생한다. 단 러스트는 --release 플래그를 사용하면 컴파일 시 패닉을 유발하는 정수 오버플로우 검사를 하지 않는다.
대신 오버플로가 발생하면  러스트가 정수 오버플로우로 인한 패닉을 발생시키지 않기 위한 래핑(wrapping) 기법을 사용한다. 래핑은 타입이 가지는 포괄 범위의 최대값보다 더 큰 값은 허용되는 최소값으로 변환되어 돌아가는 것이다. 예를 들면 u8 타입에서 256은 0으로 변환되고, 257은 1이 된다. 이 래핑 기법 외 오버플로우를 방지하기 위한 다양한 메소드를 이용하는 None, True or False 값 반환하기 등이 있다. 참고로 i32 타입이 일반적으로 가장 빠르다.

부동 소수점은 f32, f64 두 가지가 있으며, f64로 정확성이 더 높기에 기본타입으로 규정한다. 부동 소수점을 선언하는 방식은 다음과 같다. `let x = 2.0;`, `let y: f32 = 3.0;` 기본적으로 부동소수점에 대해 타입을 선언하지 않는 경우 f64가 기본 타입으로서 사용된다. 사칙 연산에 사용하는 기호로는 +, -, *, /, % 등이 있다. 각 사칙 연산은 같은 타입 간에만 이루어 진다. 따라서 부동소수점과 정수형 타입 간 사칙 연산은 불가능하며, 사칙 연산을 하려면 어느 한 쪽의 타입을 변경해주어야 한다.

서로 다른 타입을 더하려 할 때 발생하는 에러의 예시

```bash
error[E0277]: cannot add a float to an integer
 --> src/main.rs:2:18
  |
2 |     let test = 5 + 3.0;
  |                  ^ no implementation for `{integer} + {float}`
  |
  = help: the trait `Add<{float}>` is not implemented for `{integer}`

error: aborting due to previous error

```

불리언 타입은 `bool`을 통해 선언하며, true, false 두 가지가 있다. 불리언 값은 if 흐름 제어 문에서 함께 사용된다. 불리언 타입 선언 예시는 다음과 같다. `let t = true;`, `let f: bool = false;`

문자 타입은 char 타입으로 러스트가 제공하는 가장 기본적인 알파벳 타입이다. 이 문자 타입은 문자열 타입과 다르게 표시하기 위하여 큰 따옴표 대신 작은 따옴표를 사용한다. 예는 다음과 같다 `let x = 'z';` char 타입은 기본적으로 유니코드 스칼라 값이므로 ASCII 타입 보다 더 많은 문자를 표현할 수 있다. 

### 복합(Compound) 타입

복합 타입에는 튜플과 배열 두 가지가 있다. 튜플은 고정된 길이(개수)를 가지면 한번 정의되면 크기를 변경할 수 없다. 튜플의 각 요소는 타입을 가지며 다른 요소들과 같은 타입일 필요는 없다. 튜플은 `()`로 선언할 수 있다. 튜플의 첫 번째 인덱스는 0 부터 시작한다. 튜플의 선언 예시는 다음과 같다. `let tup: (i32, f64, u8) = (500, 6.4, 1);` 이렇게 선언한 튜플은 변수 tup에 저장되며 개별 값을 읽으려면 패턴 매칭을 통해 튜플 값을 해체하여 사용할 수 있다. 해체 방법은 다음과 같다.

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);

let (x, y, z) = tup;

println!("개별 값 y: {}", y)
```

위 코드는 6.4를 출력한다. y 값 6.4외에도 x에는 500, z에는 1이 할당된다. 패턴 매칭 외에도 메서드를 사용하는 것 처럼 개별 값에 접근할 수 있다. 

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);

let x = tup.0;

let y = tup.1;

let z = tup.2;
```

배열 타입은 튜플과 달리 모든 배열요소가 고정된 타입을 가져야 한다. 고정된 타입 외에도 러스트에서 배열은 고정된 길이를 가진다. 이에 따라 배열은 고정된 개수의 요소를 다룰 때 편리하게 이용할 수 있다. 배열은 `[]`로 선언할 수 있다. 예를 들면 `let a: [i32; 5] = [1, 2, 3, 4, 5];` 와 같이 선언한다. 같은 값을 가진 배열을 선언할 때는 `[;]` 과 같은 형태로 값과 길이를 [] 안에 입력하면 된다. 예시는 다음과 같다. `let a = [3; 5];` 인덱스를 통해 배열의 원소에 접근할 수 있지만 유효하지 않은 인덱스로 접근할 경우 컴파일은 할 수 있지만 런타임 에러가 발생한다.

## 함수

러스트에서 함수의 선언은 `fn` 키워드로 이루어진다. 또한 함수 선언시 함수의 내용은 {} 중괄호 안에 작성하게 된다. 러스트에서 함수와 변수의 이름에는 스네이크 케이스(snake case)를 사용하는데, 스네이크 케이스란 소문자와 함께 단어를 밑줄 기호로 구분하는 형식이다.러스트에서는 함수의 선언 순서를 고려하지 않으며 어디에든지 정의만 되어 있으면 사용 가능하다.
다른 언어와 마찬가지로 함수에 매개변수를 추가할 수 있다. 매개변수를 추가할 때는 매개변수의 타입도 설정해주어야 한다. 함수에서는 구문과 표현식을 구분해야한다. 구문은 ;으로 끝나는 반면 표현식은 ;으로 끝나지 않는다. 또한, 구문은 값을 리턴하지 않는다. 따라서 구문 안에 구문을 넣을 경우 에러가 발생한다. 에러 코드의 예시는 다음과 같다. `let x = (let y = 6);` 다른 언어에서 `x = y = 6`이 통하는 것과는 다른 양상을 보여준다. 함수의 리턴 값의 타입을 ->로 지정해주어야 한다. 함수의 리턴 값은 대부분 함수 본문 중 마지막 표현식의 결과를 리턴한다. 

## 주석

코드에 대한 주석처리는 `//` 로 한다. 한줄 이상의 주석을 필요로 할 경우 `//` 를 추가해주면 된다. 일반적으로 주석은 관련된 코드의 윗줄에 작성한다.

## 흐름제어

러스트에서 프로그램의 실행 흐름을 제어할 수 있는 가장 일반적인 방법은 if 표현식과 loop이다.

### if 표현식

if 표현식은 조건에 따라 코드가 나누어진다. 조건에 맞는 경우와 조건에 맞지 않는 경우에 따라 실행하는 코드가 달라진다. if 조건문은 반드시 불리언 타입으로 입력되어야 한다. 이는 다른 언어와의 차이점으로 반드시 러스트에서는 if 표현식의 조건을 불리언 형식으로 사용한다. else if 표현식을 추가하면 더 많은 조건을 걸 수가 있다. if 와 else, else if 조건문 안의 값 타입이 호환되어야 한다. 즉 조건이 맞는 경우와 맞지 않는 경우에 모두 같은 타입을 리턴해야 한다는 말이다.

### 루프(loop)를 이용한 반복

loop 문은 break 없으면 무한 반복한다. 만약 break 없이 중단을 하기 위해서는 컨트롤 c를 누르면 프로그램이 강제 종료된다. 만약 루프에서 값을 리턴하고자 하면 break 다음에 값을 추가하면 된다. 조건이 달린 반복문은 while 루프를 사용한다. 이 방법은 loop,if,else,break 등의 구문을 함께 이용하는 것보다 편리하다. for 구문을 통한 컬렉션 내의 요소 반복 가능하다.
