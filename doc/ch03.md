# 일반적인 프로그래밍 개념(Common Programming Concepts)

이 장에서는 대부분의 프로그래밍 언어에서 나오는 개념들과 이 개념들이 러스트에서는 어떻게 작동하는지 살펴보겠다.

## 변수와 변경 가능성(Variables and Mutability)

앞에서 살펴본 것처럼 러스트에서 모든 변수는 기본적으로(by default) '변경 불가능한(immutable)'하다. 이는 러스트가 제공하는 안전성(safety)과 손쉬운 동시성(concurrency)라는 장점을 취할 수 있도록 코드를 작성하게끔 강제하는 요소 중 하나이다. 코드를 작성하기 위한 프로젝트를 하나 만들자.

```bash
cd ..
# ~/git/rust/variables
cargo new variables
cd variables
```

다음 코드를 앞에서 생성한 프로젝트 폴더인 `/variables/src`안에 있는 `main.rs` 파일에 입력한다.

```rust
fn main() {
    let x = 5;
    println!("x의 값은: {}", x);
    x = 6;
    println!("x의 값은: ", x);
}
```

앞에 입력한 코드를 다음과 같이 실행한다. 참고로 `cargo fmt`는 코드를 정리해주는 기능을 한다.

```bash
cargo fmt
cargo run
## 빠르게 하려면, 아래와 같이 최적화 컴파일 한다.
cargo run --release
```

실행하면 다음과 같은 에러가 발생한다. 물론 실행은 중단된다.

```bash
--> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
3 |     println!("x의 값은: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
```

마지막 에러 메세지를 보면, '변경 불가능한 변수에 값을 두 번 할당할 수 없다(cannot assign twice to immutable variable)'이라고 하고 있습니다. 앞 코드를 보면 우리가 변경 불가능한 변수 `x`에 `x = 5`과 `x = 6`, 두 번 값을 할당(assign)했기 때문에 발생한 오류입니다. 이와 같이 러스트 컴파일러는 해당 코드를 실행하기전에 컴파일하면서 이러한 오류를 찾아내고 컴파일을 중지합니다.

러스트에서는, 컴파일러가 여러분이 변수가 변하지 않을 것이라고 코드를 작성하면, 이 변수는 정말로 변하지 않을 것이라는 점을 보증 해준다. 이는 여러분이 코드를 읽거나 쓰는 중에, 여러분은 특정 변수가 어디서 어떻게 변경될 수 있는지 추적할 필요가 없게 된다. 따라서 여러분의 코드는 추론하기가 더 쉽게 된다(Your code is thus easier to reason through).

모든 변수가 기본적으로 변경 불가능하지만, 변수 이름 앞에 `mut`을 추가하면 '변경 가능하게(mutable)' 만들 수 있다. 다음과 같이 코드를 변경해보자.

```rust
fn main() {
    let mut x = 5;
    println!("x의 값은: {}", x);
    x = 6;
    println!("x의 값은: {}", x);
}
```

이렇게 변경하면 아래와 같이 잘 실행된다.

```rust
❯ cargo run
   Compiling variables v0.1.0 (/Users/jaehwan/git/rust/projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 1.44s
     Running `/Users/jaehwan/git/rust/projects/variables/target/debug/variables`
x의 값은: 5
x의 값은: 6
```

버그를 방지하는 것 외에도 이러한 구별이 중요한 이유는 또 있다. '대규모 데이터 구조체(large data structures)'를 사용하는 경우에는 변경 가능한 것을 사용하는 것이 새로 인스턴스(instances)를 생성하고 거기에 복사하고 반환하는 것보다 빠를 수 있다. '소규모 데이터 구조체(smaller data structures)'에서 더 함수적 프로그래밍 스타일로 새로운 인스턴스(instances)를 생성하고 작성하는 경우에는, 약간의 성능 하락을 통해 가독성을 확보할 수 있다면 더 가치있는 선택일 수 있다(so lower performance might be a worthwhile penalty for gaining that clarity).

### 변수와 상수의 차이점

불변 변수와 상수는 차이가 있다. 상수는 항상 불변이다. 즉 `mut` 키워드를 사용할 수 없다. 상수는 `const`를 사용해 선언한다. 상수를 선언할 때는 반드시 값의 타입에 대해 지정해주어야 한다. 상수는 호출 결과나 런타임에만 계산할 수 있는 다른 값이 아닌 반드시 상수 표현식으로만 설정할 수 있다. 아래는 상수 선언 예이다.

`const MAX_POINTS: u32 = 100_000;`

러스트의 프로그래밍 관례로 상수 작성시 언더 바(_)를 가독성을 위해 사용할 수 있다.

### 변수 가리기(shadow)

러스트 프로그래밍에서도 변수를 덮어쓸 수 있다. 새 변수의 이름을 이전 변수의 이름과 똑같이 선언할 수 있고 그러면, 새 변수는 이전 변수를 덮어쓰게 된다. 예를 들면 `let x = 5;`, `let x = x + 1;`, `let x = x * 2;` 이런 식이다. 이때 첫 번째 변수가 두 번째 변수에 의해 가려졌다(shadowed)라 표현한다.


아무리 가변형 변수를 `mut`으로 설정해도 `let` 키워드 없이 변수를 재할당 하려면 컴파일-타임 에러가 발생한다. `let` 키워드 사용시 값을 변경하면서 불변형을 유지할 수 있다. `let`을 이용한 덮어쓰기와 `mut`으로 가변형 변수를 만들 때 차이점은 덮어쓰기의 경우 다른 타입의 데이터를 덮어쓸 수도 있다는 점이다.

## 데이터 타입

러스트에서 사용되는 모든 값은 그 값의 데이터 타입을 가진다. 크게 두 가지로 나눌 수 있는데 스칼라 타입과 복합 타입이다. 러스트는 컴파일 시점에 모든 변수들의 타입이 정해져 있어야 한다. 먼저 러스트의 스칼라 타입은 정수, 부동 소수점 숫자, boolean, 그리고 문자, 이렇게 네 가지가 있다.

정수형은 u32로 32비트 정수형을 의미하며, 만약 부호가 있다면 u 대신 i를 사용한다. 즉 음수의 경우 u가 아닌 i로 선언되어야 한다. 정수 형태는 각 비트 수에 따라 8, 16, 32, 64, 128까지 있다. 비트 수에 따라 달라지는 점은 포괄할 수 있는 수의 범위가 달라진다. 만약 i 형태라면 -(2^(n - 1)) 부터 (2^(n - 1) - 1) 까지 n은 비트의 수이다. u의 형태는 부호가 없기에 0 부터 (2^(n - 1) - 1)까지 포괄한다. 만약 포괄 범위 이상의 정수를 선언하려하면 정수 오버플로우 문제가 발생한다. 러스트는 정수 오버플로우 문제에서 패닉을 발생시키고, 포괄 범위의 최대값보다 더 큰 값은 허용되는 최소값으로 변환되어 돌아간다. 예를 들면 u8 타입에서 256은 0으로 변환되고, 257은 1이 된다. 그외 다양한 메소드를 이용헤 None, True or False 값 반환하기 등이 있다. 참고로 i32 타입이 일반적으로 가장 빠르다.

부동 소수점은 f32, f64 두 가지가 있으며, f64로 정확성이 더 높기에 기본타입으로 규정한다. 사칙 연산에 사용하는 기호로는 +, -, *, /, % 등이 있다. 불리언 타입은 `bool`을 통해 선언하며, true, false 두 가지가 있다.

복합 타입에는 튜플과 배열 두 가지가 있다. 튜플은 고정된 길이(개수)를 가지면 한번 정의되면 크기를 변경할 수 없다. 튜플의 각 요소는 타입을 가지며 다른 요소들과 같은 타입일 필요는 없다. 튜플은 `()`로 선언할 수 있다. 튜플의 첫 번째 인덱스는 0 부터 시작한다. 배열 타입은 튜플과 달리 모든 배열요소가 고정된 타입을 가져야 한다. 배열은 `[]`로 선언할 수 있다. 예를 들면 `let a: [i32; 5] = [1, 2, 3, 4, 5];` 와 같이 선언한다. 같은 값을 가진 배열을 선언할 때는 `[;]` 과 같은 형태로 값과 길이를 [] 안에 입력하면 된다. 참고로 배열은 튜플과 같이 길이가 고정되어 있다. 인덱스를 통해 배열의 원소에 접근할 수 있지만 유효하지 않은 인덱스로 접근할 경우 런타임 에러가 발생한다.

## 함수

러스트에서는 함수의 선언 순서를 고려하지 않으며 어디에든지 정의만 되어 있으면 사용 가능하다. 다른 언어와 마찬가지로 함수에 매개변수를 추가할 수 있다. 매개변수를 추가할 때는 매개변수의 타입도 설정해주어야 한다. 함수에서 구문과 표현식을 구분해야한다. 표현식은 ;으로 끝나지 않는다. 함수의 리턴 값의 타입을 ->로 지정해주어야 한다. 함수에 대한 주석처리는 `//` 로 한다.

## 흐름제어

if 조건문은 반드시 불리언 타입으로 입력되어야 한다. if 와 else 조건문 안의 값 타입이 호환되어야 한다. loop 문은 break 없으면 무한 반복한다. 조건이 달린 반복문 while을 사용한다. for 구문을 통한 컬렉션 내의 요소 반복 가능하다.
