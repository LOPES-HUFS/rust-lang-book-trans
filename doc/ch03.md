# 러스트 프로그래밍 정리 - 일반적인 프로그래밍 개념

러스트 프로그래밍에서 사용하는 프로그래밍 개념에 대해 정리합니다.

## 변수와 가변성

변수는 `let mut` 을 사용해 선언할 수 있다. 만약 `mut`을 사용하지 않는다면, 러스트 프로그래밍은 기본적으로 불변형 변수로 간주한다. 예를 들면 아래와 같은 코드는 컴파일 에러를 일으킨다.

```rust
fn main() {
    let x = 5;
    println!("x의 값: {}", x);
    x = 6;
    println!("x의 값: {}", x);
}
```

에러 화면은 다음과 같다.

```bash
cargo run

error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!("x의 값: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
error: could not compile `programming_concept`

To learn more, run the command again with --verbose.

```

불변 변수로 선언한 변수에 값을 할당할 수 없다는 점은 중요한 포인트이다. 왜냐하면, 불변 변수의 값이 변하게 되면 이후 프로그래밍 상에서 버그가 발생할 수 있기 때문이다. 코드에서 어떤 값이 절대 변하지 않을 것이라 생각하고 진행해나가는데 중간에 값이 바뀌게 된다면 그 코드는 원활하게 작동하지 않을 것으로 버그가 발생하게 될 것이다.

러스트는 컴파일러 차원에서 변경되지 않는다고 선언한 값을 실제로 변경할 수 없도록 보장해준다. 즉 특정 변수의 변화를 하나하나 추적할 필요가 없다는 것이다. 그러나 가변 변수가 필요한 때도 있다. 예를 들면 대용량 데이터 구조를 사용할 때이다. 이 데이터를 매번 복사하고 새로운 인스턴스를 만드는 작업 보다는 인스턴스를 가변 변수로 만드는 것이 더 빠르다. 반대로 작은 용량의 데이터 구조라면 새로운 인스턴스를 생성하고 함수형 프로그래밍 기법에 가깝게 코드를 작성하는 편이 더 낫다.  

러스트에서 변수의 불변성은 기본 변수 선언문을 사용할 때 적용된다. `mut` 키워드를 변수 선언시 붙여주면 값을 변경할 수 있는 가변 변수를 선언할 수 있다. 즉 이 키워드를 통해 코드 리딩 시 다른 사람이 변수가 가변적임을 인지할 수 있다.

아제 다시 에러의 원인을 알아보자. 에러의 원인은 불변형 변수로 선언한 x에 새로운 값을 할당하려 했기 때문이다. 값을 두번 할당하려면, 코드를 다음과 같이 변경해주면 된다. 아래 코드는 컴파일 에러를 발생시키지 않는다. x에 `mut`를 붙여 가변 변수로 만들었기 때문이다.

```rust
fn main() {
    let mut x = 5;
    println!("x의 값: {}", x);
    x = 6;
    println!("x의 값: {}", x);
}
```

### 변수와 상수의 차이점

불변 변수와 상수는 차이가 있다. 상수는 항상 불변이다. 기본 선언만으로 가지는 불변 속성이 아닌 항상 불변하는 값이다. 즉 `mut` 키워드를 사용할 수 없다. 상수는 기존의 `let` 키워드 대신 `const` 키워드를 사용해 선언한다. 상수를 선언할 때는 반드시 값의 타입에 대해 지정해주어야 한다. 상수는 전역 범위를 비롯해 어떠한 범위 내에서도 선언할 수 있으므로 필요한 곳이라면 코드 어느 곳이라도 쉽게 사용할 수 있다. 상수는 호출 결과나 런타임에만 계산할 수 있는 다른 값 예를 들면 함수 호출 결과 같은 것이 아닌 반드시 상수 표현식으로만 설정할 수 있다. 아래는 상수 선언 예이다.

`const MAX_POINTS: u32 = 100_000;`

러스트의 프로그래밍 관례로 상수 작성시 언더 바(_)를 가독성을 위해 사용할 수 있다. 참고로 상수 이름에 대문자만 사용하며 단어 사이에 밑줄을 추가하는 규칙을 사용한다.

상수는 프로그램이 실행 중인 돈안에는 선언된 범위 내에서 항상 유효한 값이므로 프로그램 구성시 여러 군데에서 사용하기에 적합하다. 프로그램 전체에서 사용하는 하드코드 된 값에 상수로 이름을 지정하는 것은 코드 유지 보수에 용이할 수 있다.

### 변수 가리기(shadow)

러스트 프로그래밍에서도 변수를 덮어쓸 수 있다. 새 변수의 이름을 이전 변수의 이름과 똑같이 선언할 수 있고 그러면, 새 변수는 이전 변수를 덮어쓰게 된다. 예를 들면 `let x = 5;`, `let x = x + 1;`, `let x = x * 2;` 이런 식이다. 이때 첫 번째 변수가 두 번째 변수에 의해 가려졌다(shadowed)라 표현한다.

이런 변수 가리기는 `mut` 키워드를 사용하는 것과는 다르다. 그 이유는 let 키워드를 이용해서 변수를 새로 선언하지 않고 값만 새로 할당할 경우 에러가 발생하기 때문이다. 즉 아래와 같은 코드는 컴파일 에러를 발생시킨다.

```rust
let mut spaces = "    ";
spaces = spaces.len();
```

위 코드는 `mut` 키워드를 사용해도 변수에 값을 재할당 할 때 `let` 키워드를 사용하지 않았기에 데이터 타입이 변경될 수 없어 컴파일 에러가 발생한다. 변수 가리기를 사용하는 방법은 다음과 같다. 아래 코드는 spaces 라는 변수 이름에 새로운 값을 할당함으로 변수 가리기를 한 것이다.

```rust
let spaces = "    ";
let spaces = spaces.len();
```

`let` 키워드 사용시 값이 새로운 값으로 변경되지만 여전히 변수는 불변형을 유지할 수 있다. `let`을 이용한 덮어쓰기와 `mut`으로 가변형 변수를 만들 때 차이점은 덮어쓰기의 경우 다른 타입의 데이터를 덮어쓸 수도 있다는 점이다.

## 데이터 타입

러스트에서 사용되는 모든 값은 그 값의 데이터 타입을 가진다. 데이터 타입은 데이터를 올바르게 처리하기 위해 데이터의 종류를 명시하기 위한 것이다. 데이터 타입은 크게 두 가지로 나눌 수 있는데 스칼라 타입과 복합 타입(Compound)이다. 러스트는 정적 언어로서 컴파일 시점에 모든 변수들의 타입이 정해져 있어야 한다. 컴파일러는 타입 추론을 통해 변수에 할당된 값이나 변수의 사용을 보고 실제 타입을 예측한다. 따라서 변수가 여러 타입이 될 수 있을 때는 반드시 타입 애노테이션을 통해 타입을 명시해 주는 것이 좋다.

### 스칼라 타입

먼저 러스트의 스칼라 타입은 정수, 부동 소수점 숫자, boolean, 그리고 문자, 이렇게 네 가지가 있다.
아래의 표는 정수형 타입 표이다.

| 크기  | 부호 있음  | 부호 없음 |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |

위의 표에서 u32 타입을 예로 들어보자. 정수형 u32는 32비트 정수형 데이터 타입을 의미한다. 만약 부호가 있는 데이터 타입이면 u 대신 i를 사용한다. 즉 음수의 경우 u가 아닌 i로 선언되어야 한다. 정수 형태는 각 비트 수에 따라 8, 16, 32, 64, 128까지 있다. 비트 수에 따라 달라지는 점은 포괄할 수 있는 수의 범위가 달라진다. 만약 i 형태라면 -(2^(n - 1)) 부터 (2^(n - 1) - 1) 까지 n은 비트의 수이다. u의 형태는 부호가 없기에 0 부터 (2^(n - 1) - 1)까지 포괄한다.

숫자형이 아닌 usize 와 isize의 경우 현재 프로그램이 실행 중인 컴퓨터의 종류에 따라 그 크기가 결정되는 데이터 타입들이다. 만일 64bit 환경에서 실행된다면 코드는 64비트가 되고 32bit 환경에서 실행된다면, 코드는 32비트가 된다. isize, usize 타입은 컬렉션 타입의 인덱스를 참조할 때 주로 사용된다.

그렇다면 숫자형 데이터 타입들에서 숫자의 포괄 범위 이상의 정수를 선언하려하면 정수 오버플로우 문제가 발생한다. 단 러스트는 --release 플래그를 사용하면 컴파일 시 패닉을 유발하는 정수 오버플로우 검사를 하지 않는다.
대신 오버플로가 발생하면  러스트가 정수 오버플로우로 인한 패닉을 발생시키지 않기 위한 래핑(wrapping) 기법을 사용한다. 래핑은 타입이 가지는 포괄 범위의 최대값보다 더 큰 값은 허용되는 최소값으로 변환되어 돌아가는 것이다. 예를 들면 u8 타입에서 256은 0으로 변환되고, 257은 1이 된다. 이 래핑 기법 외 오버플로우를 방지하기 위한 다양한 메소드를 이용하는 None, True or False 값 반환하기 등이 있다.

어떠한 타입을 선언해야하는지 잘 모를 때는 러스트의 기본형을 사용하는 것도 좋은 방법이다. 러스트 정수형 타입의 기본은 i32 타입으로 일반적으로 가장 빠르다.

러스트는 부동 소수점을 가진 숫자를 처리하기 위해 f32, f64 두 가지의 부동 소수점 타입이 있다. f64로 정확성이 더 높기에 기본타입으로 규정한다. 부동 소수점을 선언하는 방식은 다음과 같다. `let x = 2.0;`, `let y: f32 = 3.0;` 기본적으로 부동소수점에 대해 타입을 선언하지 않는 경우 f64가 기본 타입으로서 사용된다. f32 타입은 단정도 부동 소수점이며, f64는 배정도 부동소수점을 표현한다.

사칙 연산에 사용하는 기호로는 +, -, *, /, % 등이 있다. 각 사칙 연산은 같은 타입 간에만 이루어 진다. 따라서 부동소수점과 정수형 타입 간 사칙 연산은 불가능하며, 사칙 연산을 하려면 어느 한 쪽의 타입을 변경해주어야 한다. 사칙 연산을 위한 연산자 이외에도 러스트에서는 다른 연산자를 제공한다.

서로 다른 타입을 더하려 할 때 발생하는 에러의 예시이다.

```bash
error[E0277]: cannot add a float to an integer
 --> src/main.rs:2:18
  |
2 |     let test = 5 + 3.0;
  |                  ^ no implementation for `{integer} + {float}`
  |
  = help: the trait `Add<{float}>` is not implemented for `{integer}`

error: aborting due to previous error

```

불리언 타입은 `bool`을 통해 선언하며, true, false 두 가지가 있다. 불리언의 크기는 1byte이다. 불리언 값은 if 흐름 제어 문에서 함께 사용된다. 불리언 타입 선언 예시는 다음과 같다. `let t = true;`, `let f: bool = false;`

문자 타입은 char 타입으로 러스트가 제공하는 가장 기본적인 알파벳 타입이다. 이 문자 타입은 문자열 리터럴 타입과 다르게 표시하기 위하여 큰 따옴표 대신 작은 따옴표를 사용한다. 예는 다음과 같다 `let x = 'z';` char 타입은 기본적으로 유니코드 스칼라 값이므로 ASCII 타입 보다 더 많은 문자를 표현할 수 있다.

### 복합(Compound) 타입

복합 타입에는 튜플(tuples)과 배열(arrays) 두 가지가 있다. 튜플은 고정된 길이(개수)를 가지면 한번 정의되면 크기를 변경할 수 없다. 튜플의 각 요소는 타입을 가지며 다른 요소들과 같은 타입일 필요는 없다. 각 요소의 구분은 쉼표를 통해 이루어진다. 튜플은 `()`로 선언할 수 있다. 튜플의 첫 번째 인덱스는 0 부터 시작한다. 튜플의 선언 예시는 다음과 같다. `let tup: (i32, f64, u8) = (500, 6.4, 1);` 이렇게 선언한 튜플은 변수 tup에 저장되며 개별 값을 읽으려면 패턴 매칭을 통해 튜플 값을 해체하여 사용할 수 있다. 해체 방법은 다음과 같다.

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);

let (x, y, z) = tup;

println!("개별 값 y: {}", y)
```

위 코드는 6.4를 출력한다. y 값 6.4외에도 x에는 500, z에는 1이 할당된다. 패턴 매칭 외에도 메서드를 사용하는 것 처럼 개별 값에 접근할 수 있다.

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);

let x = tup.0;

let y = tup.1;

let z = tup.2;
```

배열 타입은 튜플과 달리 모든 배열요소가 고정된 단일 타입을 가져야 한다. 고정된 타입 외에도 러스트에서 배열은 고정된 길이를 가진다. 이에 따라 배열은 고정된 개수의 요소를 다룰 때 편리하게 이용할 수 있다. 배열은 `[]`로 선언할 수 있다. 요소의 구분은 마찬가지로 쉼표로 이루어진다. 예를 들면 `let a: [i32; 5] = [1, 2, 3, 4, 5];` 와 같이 선언한다. 같은 값을 가진 배열을 선언할 때는 `[;]` 과 같은 형태로 값과 길이를 [] 안에 입력하면 된다. 예시는 다음과 같다. `let a = [3; 5];` 배열의 원소에 접근하려면 인덱스를 통해 접근할 수 있다. 그러나, 만약 배열의 길이 이상의 유효하지 않은 인덱스로 접근할 경우 컴파일은 할 수 있지만 런타임 에러가 발생한다. 즉 러스트는 인덱스를 이용해 배열 요소를 읽을 때 전체 배열 길이보다 작은 값인지를 스스로 검사하는데 이 때 더 큰 값이 나오게 되면 패닉이 발생하게 된다.

에러의 예는 다음과 같다.

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

에러 화면 출력은 다음과 같다.

```rust
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

이 에러가 보여주는 바는 러스트가 안정성 원리가 개입하는 것을 알려준다. 많은 저수준 언어들은 이런 검사를 하지 않으며, 유효하지 않은 인덱스 값을 사용할 경우 엉뚱한 메모리 값을 읽을 수 있다. 그러나 러스트는 이런 일을 방지하고자 유효하지 않은 인덱스로 읽으려는 시도가 있다면 프로그램을 즉각 중단시킨다. 즉 보호 장치를 제공하는 것이다.

## 함수

러스트에서 함수의 선언은 `fn` 키워드로 이루어진다. 또한 함수 선언시 함수의 내용은 {} 중괄호 안에 작성하게 된다. 러스트에서 함수와 변수의 이름에는 스네이크 케이스(snake case)를 사용하는데, 스네이크 케이스란 소문자와 함께 단어를 밑줄 기호로 구분하는 형식이다.러스트에서는 함수의 선언 순서를 고려하지 않으며 어디에든지 정의만 되어 있으면 사용 가능하다. 함수의 선언 예시는 다음과 같다.

```rust
fn main() {
    println!("안녕하세요");

    another_function();
}

fn another_function() {
    println!("또다른 함수");
}
```

다른 언어와 마찬가지로 함수에 매개변수를 추가할 수 있다. 매개변수를 추가할 때는 매개변수의 타입도 설정해주어야 한다. 함수의 시그너처에는 매개변수를 사용할 때 타입을 명시해주어야 한다. 이것은 러스트의 의도적인 디자인이다. 즉 이러면 함수의 매개변수가 코드 내에서 어떻게 사용되는지 별도로 추적할 필요가 없이 타입을 바로 확인할 수 있는 장점이 있다. 매개 변수의 타입 애노테이션만 명확하면 되지 모든 매개변수의 타입이 같을 필요는 없다.

함수에서는 구문(statements)과 표현식(expression)을 구분해야한다. 러스트의 경우 표현식 기반의 언어이므로 구문과 표현식의 구분은 매우 중요하다. 구문은 ;으로 끝나는 반면 표현식은 ;으로 끝나지 않는다. 또한, 표현식은 최종 결괏값으로 평가(evaluate)되는 반면 구문은 값을 리턴하지 않는다. 따라서 구문 안에 구문을 넣을 경우 에러가 발생한다.
에러 코드의 예시는 다음과 같다. `let x = (let y = 6);` c언어나 루비와 같은 다른 언어에서 `x = y = 6`이 통하는 것과는 다른 양상을 보여준다.
러스트에서 함수의 리턴 값은 함수 본문의 마지막 표현식을 의미한다. 물론 함수의 본문이 완전히 끝나지 않아도 `return` 키워드를 사용하면 중간에 리턴 값을 반환할 수 있다.
함수의 작성시에는 함수의 리턴 값의 타입을 ->로 지정해주어야 한다. 함수의 리턴 값은 대부분 함수 본문 중 마지막 표현식의 결과를 리턴한다. 구문과 표현식 구분을 통한 에러의 예시 코드는 다음과 같다.

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```

위 코드는 플러스 원 함수의 마지막 부분이 ;로 인해 구문으로 표현되었기에 에러가 발생한다. 에러의 발생원인은 구문은 아무것도 리턴하지 않기에 지정한 리턴 값의 타입애노테이션과 타입 불일치가 발생하여 에러가 발생하는 것이다. 에러를 고치려면 표현식으로 바꾸면 되는데, ; 만 제거 해주면된다.

## 주석

코드에 대한 주석처리는 `//` 로 한다. 한줄 이상의 주석을 필요로 할 경우 `//` 를 추가해주면 된다. 일반적으로 주석은 관련된 코드의 윗줄에 작성한다.

## 흐름제어

러스트에서 프로그램의 실행 흐름을 제어할 수 있는 가장 일반적인 방법은 if 표현식과 loop이다.

### if 표현식

if 표현식은 조건에 따라 코드가 나누어진다. 조건에 맞는 경우와 조건에 맞지 않는 경우에 따라 실행하는 코드가 달라진다. if 조건문은 반드시 불리언 타입으로 입력되어야 한다. 이는 다른 언어와의 차이점으로 반드시 러스트에서는 if 표현식의 조건을 불리언 형식으로 사용한다. else if 표현식을 추가하면 더 많은 조건을 걸 수가 있다. if 와 else, else if 조건문 안의 값 타입이 호환되어야 한다. 즉 조건이 맞는 경우와 맞지 않는 경우에 모두 같은 타입을 리턴해야 한다는 말이다.

### 루프(loop)를 이용한 반복

loop 문은 break 없으면 무한 반복한다. 만약 break 없이 중단을 하기 위해서는 컨트롤 c를 누르면 프로그램이 강제 종료된다. 만약 루프에서 값을 리턴하고자 하면 break 다음에 값을 추가하면 된다. 조건이 달린 반복문은 while 루프를 사용한다. 이 방법은 loop,if,else,break 등의 구문을 함께 이용하는 것보다 편리하다. for 구문을 통한 컬렉션 내의 요소 반복 가능하다.
