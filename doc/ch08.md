# 러스트 - 일반적인 컬렉션

러스트의 표준 라이브러리에는 컬렉션이라 불리며 여러개의 데이터 구조들이 저장되어 있다. 컬렉션에는 다수의 값을 담을 수 있고 그 값들은 힙 메모리에 저장되게 된다. 즉 프로그램 실행이 메모리가 늘어나거나 줄어들거나 할 것이다. 이번에는 벡터, 스트링, 해쉬맵 컬렉션에 대해 알아보겠습니다. 물론 표준 라이브러리에는 이 3가지 이상의 컬렉션 데이터 구조들이 존재합니다.

## 벡터

벡터는 `Vec<T>`로 단일 데이터 구조 안에 하나 이상의 값을 저장할 수 있게 해주는 컬렉션입니다. 단 벡터 내의 값들은 모두 단일한 타입으로 이루어져야 합니다. 비어있는 새로운 벡터는 만드는 방법은 다음과 같습니다. `let v: Vec<i32> = Vec::new();` 이 코드에서 `Vec::new()` 키워드가 새로운 벡터를 만드는 역할을 합니다.
새로운 벡터를 만들 때 들어올 값에 대한 정보를 미리 지정해줘야 하는 점은 중요합니다. 왜냐하면, 빈 공간의 벡터이기에 러스트에서는 타입 애노테이션을 해주지 않으면 이 벡터에 무슨 값이 들어올지 알지 못하기 때문입니다. 따라서 특정한 타입의 값을 벡터에 저장하고 싶다면, `<i32>` 라는 키워드와 같이 타입을 미리 지정해주어야 합나다. 여기서는 i32 타입으로 지정해주었습니다.
물론 러스트에서 자동으로 값을 보고 타입을 유추할 수 있기 때문에 타입 애노테이션이 필요 없는 경우도 있습니다. 초기값을 가지는 벡터를 만드는 방법은 매크로를 사용하는 것입니다. 벡터 매크로는 `vec!` 키워드로 사용합니다. 이 매크로를 통해 초기값 1,2,3 이 있는 벡터를 만드는 예시는 다음과 같습니다. `let v = vec![1, 2, 3];` 이 코드 예시는 앞서 v를 만들 때와 달리 타입 명시가 필요하지 않는데 러스트가 초기값을 보고 자동으로 유추할 수 있기 때문입니다.

### 벡터 수정하기

벡터에 값을 추가하는 방법은 push 메서드를 이용하는 것이다. 단 값을 입력 하거나 입력한 값을 다른 값으로 변경하려면 가변형 변수를 선언해야 한다. 즉 `mut` 키워드를 이용해서 빈 벡터 변수를 선언해야 한다. 값 입력 예는 다음과 같다. 값의 입력시 타입 애노테이션은 할 필요가 없다. 러스트가 알아서 데이터로 부터 값의 타입을 유추할 수 있기 때문이다. 값의 입력은 pust 메서드로 이루어진다. 또한, pop 메서드도 존재한다.

```rust
let mut vec = Vec::new();

vec.push(1);
vec.push(2);
```

값의 변경의 예는 다음과 같다. 기존의 값이 1인 0 번째 값을 7로 변경하는 코드이다.

```rust
vec[0] = 7;
```

### 벡터 해제

벡터 역시 다른 구조체와 마찬가지로 범위를 벗어날 때 메모리가 해제되어 drop 메서드가 호출된다. 이말은 변수의 사용은 범위 내에서만 가능하다는 말이다. 벡터의 메모리가 해제된다는 것은 그 안의 값들의 메모리도 같이 해제된다는 것이다. 이에 따라 벡터 안의 값이 참조형일 경우 문제가 발생할 수 있다. 이 때 발생하는 문제는 변수의 값에 대한 수명 문제가 발생하게 된다. 이러한 수명 문제를 피하기 위해서 벡터에 값에 참조형 값을 사용하는 것을 피하는 것이 좋다.

### 벡터로부터 값 읽기

벡터에서 값을 읽어오는 방법은 get 메서드 사용과 인덱싱 방법 두 가지가 있다. 먼저 인덱스 방식의 예이다.

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
```

인덱스 방식에서 주의할 점은 인덱싱은 0부터 이루어진다는 점이다. 즉 3번째 원소의 인덱스는 2이다. 또 다른 주의할 점은 인덱싱을 할 때 &(참조)와 []를 이용한다는 점이다. 참조를 사용하는 이유는 값의 소유권 혹은 수명 문제를 피하기 위한 것으로 보여진다. 실제로는 참조가 반드시 필요한 것은 아니다 참조가 없이도 인덱싱이 이루어질 수는 있다. `println!("{}", v[1])` 이런식으로 인덱싱을 할 수 있다. [] 는 안에 인덱스 번호를 넣어주어 해당 인덱스의 값을 조회할 수 있게 하는 역할을 한다.

두 번째 방법인 get 메서드의 사용 예는 다음과 같다.

```rust
let third: Option<&i32> = v.get(2);
```

get 메서드는 Option<&T> 타입의 값을 리턴하기에 변수의 타입 애노테이션을 Option<&i32>로 해주었다.

이제 이 두 가지 방법에서 존재하지 않은 인덱스를 어떻게 다루는지 살펴보자.

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

먼저 인덱스의 방식에서 존재하지 않은 인덱스를 조회하려하면 패닉이 발생한다. 이 방법은 벡터에는 존재하지 않는 값에 접근할 때 프로그램을 강제 종료 시키는 용도로 유용하게 사용할 수 있다. 반면 get 메서드의 경우 존재하지 않은 번호의 값을 조회하려하면 none 을 리턴하게 된다. 패닉을 발생시키지는 않는다. 이 방법은 벡터 안의 개수를 정확히 몰라 그 범위를 벗어나는 값을 자주 조회하게 되는 시도가 많을 때 유용하다. 인덱싱 방법은 패닉으로 인한 프로그램 강제 종료가 일어나는 반면 get은 강제 종료가 일어나지 않기에 사용자 친화적인 방법이라 말할 수 있다.

이제 참조한 값을 저장하는 이유에 대해 더 자세히 알아보자 참조는 소유권과 연관된다. 벡터의 값을 참조로 저장하는 경우 대여값 검사가 진행되며, 이 검사에서는 소유권과 대여 규칙이 적용된다. 이에 따라 가변 참조와 불변 참조를 동시에 가질 수 없는 규칙은 벡터에서도 적용된다.

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);
```

이 코드는 컴파일 에러가 발생하게 되는데 그 이유는 벡터의 동작 방식에서 기인한다. 새로운 요소를 벡터의 끝에 추가하는 것은 새로 메모리를 할당하여 예전 요소를 새 공간에 복사하는 일을 필요로 할 수 있다. 이는 벡터가 모든 요소들을 붙여서 저장할 공간이 충분치 않는 환경에서 일어날 수 있다. 이 경우, 첫번째 요소에 대한 참조자는 할당이 해제된 메모리를 가리키게 될 것이기에 에러가 발생하게 된다. 이런 해제된 메모리를 가리키게 되는 상황을 보호하고자 에러가 일어나는 것이다.

### 벡터의 저장된 값 순회하기

벡터에 저장된 값읋 확인하기 위해서는 for 루프를 이용한다. 이 코드는 for 루프를 이용해 벡터의 불변 참조를 프린트해서 보여주는 코드이다.

```rust
let v = vec![1,2,3,4,5];
for i in &v {
    println!("{}", i);
}
```

불변 참조가 아닌 가변 참조를 얻는 방법도 있다. 

```rust
let mut v = vec![1,2,3,4,5];
for i in &mut v {
    *i += 50;
}
```

가변 참조는 &mut로 이루어지며, 값의 변경을 위해서는 * 역참조 연산자의 사용이 필수적이다. 참조한 값을 따라가야하기 때문에 역참조 연산자를 붙여 가변 참조로 읽어온 값을 변경할 수 있다.

### 열거자를 이용해 여러 타입 저장하기

기존의 벡터는 같은 타입의 값들만 저장하는 반면 열거자를 이용하면 하나의 벡터에 여러 타입의 값을 저장할 수 있다. 코드의 예는 다음과 같다.

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

이 방법은 벡터가 열거자 타입을 단일 타입으로 인식하기에 가능한 방법이다. 즉 열것 값의 타입은 다중 타입이지만 그 값들은 열거자라는 단일 타입에 있기에 벡터에 저장되는 값의 타입은 열거자 타입 하나로 단일 타입이라 인식된다. 이에 따라 최종적으로는 여러 타입을 가진 벡터를 만들어 낼 수 있다. 이 방법은 또한 각 열것 값의 타입을 명시하기에 타입 간 불일치 연산 에러를 방지할 수 있다는 점도 있다. 단 프로그램을 작성하는 시점에 프로그램이 다루는 타입들을 명확히 알 수 없는 경우 이 방법의 사용은 별로 도움이 되지 않는다. 이런 때는 트레이트 객체를 사용하는 방식을 통해 벡터를 구성해 나가면 된다.

## String 타입에 UTF-8 형식의 텍스트 저장하기

러스트의 문자열은 일반적으로 UTF-8 형식으로 저장되며, 더 복잡한 구조를 지닌다. 문자열을 컬렉션의 일종으로 보는 이유는 러스트 문자열이 바이트(byte) 컬렉션으로 구현되어 있으며, 관련 메서드를 제공하고 있기 때문이다.

### 문자열은 무엇일까?

러스트는 오직 한가지 문자열 타입만 지원하는데 문자열 슬라이스인 str 타입이다. 이 타입은 주로 값을 대여한 &str 형태의 참조 형태로 자주 볼 수 있다. 문자열 슬라이스는 UTF-8 형식으로 인코딩되어 저장된 문자열에 대한 참조이다. 이런 문자열 타입과 달리 String 타입은 러스트의 표준 라이브러리가 제공하는 타입이다. String 타입은 길이 조정이나 내용 변경 소유 등이 가능하며 UTF-8로 인코딩 된 문자열 타입이다.
러스트 표준 라이브러리는 OsString, OsStr, CString, CStr 등의 다양한 문자열 타입을 제공한다. 각 타입 들의 이름이 String과 Str로 끝나는 것의 의미는 String,Str 처럼 소유된 값과 대여된 값을 의미하는 것이다.

### 문자열 생성하기

벡터와 마찬가지로 new를 이용해 새 문자열을 생성할 수 있다. 예시 코드는 다음과 같다. 아래 코드는 비어있는 스트링을 생성하는 코드이다.

```rust
let mut s = String::new();
```

문자열 초기값을 제공한 상태에서 문자열을 생성할 수도 있다. 그때 사용하는 메서드는 to_string 메서드이다.

```rust
let data = "초기값";

let s = data.to_string();

let s = "초기값".to_string();
```

문자열 리터럴을 이용해 문자열을 생성하려면 String::from 함수를 사용해도 된다.

```rust
let s = String::from("initial contents");
```

문자열 활용 예는 다양하며, 많은 수의 옵션을 제공하는 여러 API를 사용할 수 있다. String::from, to_string() 는 같은 작업을 수행하는 것들이다. UTF-8 인코딩을 사용하므로 다양한 언어의 데이터를 저장할 수 있다.

```rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
```

### 문자열 수정하기

문자열의 크기는 늘어날 수 있다. 또한 문자열의 내용도 벡터와 유사하게 변경할 수 있다. + 연산자나 format! 매크로를 이용해서 연결 가능하다.

push_str 과 push 메서드를 이용해 문자열을 덫붙일 수 있다. push_str은 문자열 슬라이스 타입을 String에 덫붙이는 메서드이다. 코드 예는 다음과 같다.

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

위 코드의 결과로 우리는 foobar 문자열을 저장할 수 있다. push_str 메서드가 문자열 슬라이스 타입을 이용하는 이유는 변수의 소유권을 가질 필요가 없기 때문이다. 그렇기 때문에 다음과 같이 저장할 문자열 슬라이스를 변수로 만들고 String에 붙여도 지속적으로 변수를 사용할 수 있다.

```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(&s2);
println!("s2 is {}", s2);
```

소유권이 없기 때문에 문자열을 붙이고 나서 마지막에 변수를 프린트하여도 에러가 발생하지 않는다.

push 메서드는 하나의 문자(character)를 매개변수로 전달 받아 String에 추가한다. 코드 예는 다음과 같다.

```rust
let mut s = String::from("lo");
s.push('l');
```

코드 실행 결과는 lol이라는 문자열이 저장된 s 변수를 얻게 된다. push 메서드 이외에도 + 연산자나 format! 매크로를 사용해 문자열을 연결할 수 있다. + 연산자를 이용하는 방식의 예는 다음과 같다.

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2;
```

이렇게 문자열을 연결했을 때 s1을 더이상 사용하지 못하게 된다. 메모리가 해제되어 s1의 변수의 메모리 포인터가 사라지기 때문이다. 또한 s2 변수를 참조 형식으로 더하는 이유도 있다. s1 변수의 메모리 해제와 s2 변수의 참조 사용 원인은 +연산자가 내부적으로 호출하는 메서드의 시그너처 때문이다. add 메서드를 내부적으로 사용하는데 add 메서드의 구조는 다음과 같다.

```rust
fn add(self, s: &str) -> String {
```

이는 표준 라이브러리에 있는 정확한 시그니처는 아니다. 표준 라이브러리 내에서 add는 제네릭을 이용하여 정의되어 있다. 여기서는 제네릭에 구체 타입(concrete type)을 대입한 add의 시그니처를 보는 중인데, 이는 우리가 String 값으로 이 메소드를 호출했을때 생긴다.

먼저 s2는 &를 가지고 있는데, 이는 add 함수의 s 파라미터 때문이다. add 함수의 내용은 첫번째 스트링에 두번째 스트링의 참조자를 더하고 있음을 추측할 수 있다. add 의 매개변수가 참조형 스트링 &String인데 어째서 위 코드의 &s2를 전달할 수 있는지에 대한 의문이 있을 수 있다. &String 전달받아도 에러가 발생하지 않는 이유는 컴파일러가 &String 인수를 &str 타입으로 알아서 변환해주기 때문에 컴파일 에러가 발생하지 않을 수 있다. 변환 방법에는 강제 역참조가 사용된다.

add 메서드는 참조를 사용하기에 매개변수의 s의 소유권을 가지지 않으므로 변수에 문자열을 추가해도 여전히 s사용할 수 있다. 이는 add의 메서드에서 self가 매개변수의 소유권을 가지게 되기 때문이다. self는 여기서 s1의 역할이 된다. 이에 따라 s1은 add 메서드 범위 내로 들어가 메모리가 해제되어 더 이상 유효하지 않게 된다. 이 말은 단순히 두 문자열의 값을 복사해 덫붙이는 것이 아닌 s1의 소유권을 확보하고 s2 값을 복사해 그 결과인 s3에 소유권을 리턴하는 방식으로 + 연산자가 작동하는 것이다. 이 방식은 메모리 관리면에서 문자열을 여러번 복사하는 방식 보다 더 효율적이다.

문자열을 여러개 결합할 때 + 연산자 사용은 효율적이지 못할 수 있다.

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;

```

위 코드에서 변수 s는 작동하지만 +와 - 기호 때문에 가독성이 떨어진다. 이때 사용에 적합한 것이 format! 매크로이다. 사용 예는 다음과 같다.

```rust

let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
```

format! 매크로는 println!과 똑같은 방식으로 작동한다. 스크린에 결과를 출력하는 대신 결과를 담은 String을 반환한다. + 연산자를 이용해도 만들 수 있지만 format!을 이용한 버전이 훨씬 읽기 쉽고, 또한 어떠한 파라미터들의 소유권도 가져가지 않는다.

### 문자열의 인덱스

러스트에서는 다른 프로그램 언어와 달리 문자열의 인덱스로 접근이 허용되지 않는다. 즉 다음과 같은 코드는 에러가 발생한다.

```rust
let s1 = String::from("hello");
let h = s1[0];
```

```bash
error: the trait bound `std::string::String: std::ops::Index<_>` is not
satisfied [--explain E0277]
  |>
  |>     let h = s1[0];
  |>             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
```

코드 실행시 위와 같은 에러가 발생한다.

그렇다면 러스트는 왜 문자열 인덱싱을 지원하지 않는 것일까? 이에 대한 해답을 알기위해 러스트가 문자열을 메모리에 어떻게 저장하는지 부터 알아보자.
String은 Vec<u8> 타입을 한번 감싼(wrapper) 것이다. 예제는 다음과 같은 것이 있다.

```rust
let len = String::from("Hola").len();
```

이 경우, len은 4가 되는데, 이는 스트링 “Hola”를 저장하고 있는 Vec이 4바이트 길이라는 뜻이다. UTF-8로 인코딩되면 각각의 글자들이 1바이트씩 차지한다. 그러나 다음과 같은 예제는 다르다.

```rust
let len = String::from("안녕하세요").len();
```

이 문자열의 길이는 5이다. 그러나 러스트에서는 이 문자열의 길이는 15이다. 그 이유는 러스트에서 안녕하세요라는 문자를 UTF-8로 인코딩하면 15바이트를 사용하기 때문이다. 15바이트가 되는 원리는 문자열 안 유니코드 스칼라 값이 3바이트의 공간을 차지하기 떼문이다. 그렇기 때문에 문자열 인덱스로 접근할 경우 올바른 유니코드 스칼라 값을 가져오지 못하는 경우가 생길 수 있다.

```rust
let hello = String::from("안녕하세요");
let answer = &hello[0];
```

위 예제는 올바르게 작동하지 않는다. answer의 값은 무엇이 되어야 할까요? UTF-8로 인코딩될 때, 안의 첫번째 바이트는 236이고, 두번째는 149이므로, answer는 사실 236 되어야 하지만, 236은 그 자체로는 유효한 문자가 아니다. 236을 반환하는 것은 사람들이 이 스트링의 첫번째 글자를 요청했을 경우 사람들이 기대하는 것이 아니다.

하지만 러스트가 인덱스 0에 가지고 있는 유일한 데이터이기에 러스트는 그것을 반환한다. 바이트 값을 반환하는 것은 아마도 유저들이 원하는 것이 아니다. 심지어는 라틴 글자들만 있을 때도 마찬가지이다. &"hello"[0]는 h가 아니라 104를 반환한다. 기대치 않은 값을 반환하고 즉시 발견하기 힘들지도 모를 버그를 야기하는 것을 방지하기 위해, 러스트는 이러한 코드를 전혀 컴파일하지 않고 이러한 오해들을 개발 과정 내에서 미리 방지한다.

러스트의 관점에서 볼때 문자열은 크게 3가지이다. 바이트, 스칼라 값, 그리고 그래핌 클러스터(grapheme clusters 우리가 문자라고 부르는 것에 가장 가까운 것) 예를 들어 한글의 안녕하세요는 다음과 같은 u8 값을 저장한다. [236,149,136,235,133,149,237,149,152,236,132,184,236,154,148] 이 15개의 바이트 값이 컴퓨터가 데이터를 저장하는 형태이다. 이 데이터를 러스트의 스칼라 값 표현 방식으로 보면 다음과 같다. ['안','녕','하','세','요'] 이 벡터에는 5개의 char 값이 저장되어 있다. 그래핌 클러스터로 확인해도 같은 결과를 볼수 있다.

러스트는 컴퓨터가 저장하는 가공되지 않은(raw) 스트링을 번역하는 다른 방법을 제공하여, 데이터가 담고 있는 것이 어떤 인간의 언어든 상관없이 각각의 프로그램이 필요로 하는 목적에 따라 해석한다.

러스트가 String을 인덱스로 접근하여 문자를 얻지 못하도록 하는 마지막 이유는 인덱스 연산이 언제나 상수 시간(O(1))에 실행될 것으로 기대받기 때문이다. 그러나 String을 가지고 그러한 성능을 보장하는 것은 불가능하다. 그 이유는 러스트가 스트링 내에 얼마나 많은 유효 문자가 있는지 알아내기 위해 내용물의 시작 지점부터 인덱스로 지정된 곳까지 쭉 검사해야 하기 때문이다.

### 문자열 슬라이스 하기

러스트에서 스트링 인덱싱의 리턴 타입이 어떤 것인지 (바이트 값인지, 캐릭터인지, 문자소 클러스터인지, 혹은 스트링 슬라이스인지) 명확하지 않기 때문에 스트링의 인덱싱은 좋은 방법이 아니다. 그럼에도 불구하고 스트링 인덱싱을 한다면 조건을 명확히 명시해야한다.

인덱스를 이용해 문자열 슬라이스를 만들고자 하면, [] 안에 인덱스 값이 아닌 바이트 범위를 입력해야 한다. 예를 들면 다음과 같다.

```rust
let hello = "안녕하세요";
let s = &hello[0..3];
```

이 코드는 변수 s에 문자열의 처음에서 3바이트 값을 저장하는 &str 타입이다. 한글자는 3바이트를 차지하므로 값은 안이 된다. 만일 벡터에서와 같이 인덱스에 유효하지 않은 바이트 구간을 제공할 경우 패닉이 발생하게 된다. 이에 따라 바이트 범위를 사용할 때 주의해야한다.

### 문자열을 순회하는 메서드

개별적인 유니코드 스칼라 값에 접근하는 가장 좋은 방법은 chars 메서드를 이용하는 것이다. chars를 "안녕하세요" 에 대해 호출하면 char타입의 5개의 값으로 나누어 반환한다. 이를 통해 각각의 요소에 접근할 수 있게 된다. 물론 이 방법은 반복문 for와 함께 사용된다. 바이트 값을 리턴하는 bytes 메서드도 존재하며, 문자열의 바이트를 리턴할 필요가 있을 때 사용한다.

```rust

for c in "안녕하세요".chars() {
    println!("{}", c);
}

```

유효한 유니코드 스칼라 값은 1byte 보다 큰 값으로 구성된다는 점을 명심하자. 문자열에서 그래핌 클러스터를 가져오는 방식은 표준 라이브러리에서 지원하지 않는다. 다른 크레이트를 찾아서 이 기능을 사용할 수 있다.
러스트에서 문자열을 다루는 방식은 복잡하지만, 개발과정에서 ASCII 문자가 아닌 다른 형식의 문자를 다룰 때 에러를 처리해야할 필요가 없다는 장점이 있다.

## 키와 값을 저장하는 해시맵

HashMap<K, V> 타입은 K 타입의 키에 V 타입의 값을 매핑한 것을 저장한다. 이 매핑은 해쉬 함수(hashing function) 을 통해 동작하는데, 해쉬 함수는 이 키와 값을 메모리 어디에 저장할지 결정한다. 다른 프로그래밍 언어에서 유사한 형태의 데이터 구조를 제공하며, 해시테이블(hash table),딕셔너리(dictionary), 연관배열(associative array) 등의 다른 이름으로 사용된다.

해시맵의 장점은 인덱스가 아닌 키에 있다. 키 값을 조회하여 데이터를 확인할 때 유용하다. 예를 들면 팀의 이름을 키로 팀의 점수를 값으로 저장해서 팀의 이름 조회만으로 점수를 확인할 수 있다.

### 새로운 해시맵 생성하기

빈 해쉬맵은 new로 생성할 수 있고, insert를 이용하여 요소를 추가할 수 있다. 예시 코드는 다음과 같다.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("블루"), 10);
scores.insert(String::from("옐로"), 50);

```

먼저 첫번째 코드인 use 구문을 사용하는 이유는 다른 범용 컬렉션에 비해 사용빈도가 낮아 자동으로 가져오는 기능이 없기 때문이다. 사용빈도의 영향은 표준 라이브러리의 지원이 미비한 점에서도 찾아 볼 수 있는데, 해시맵 생성의 내장 매크로를 지원하지 않는게 그것이다.
해시맵은 벡터와 마찬가지로 힙메모리에 저장된다. 또한, 벡터처럼 해시맵 역시 모든 키값 들 간에 타입이 같아야 하며, 이는 값의 부분에서도 마찬가지이다.
해시맵을 생성하는 또다른 방법은 튜플의 벡터에 대해 collect 메소드를 사용하는 것이다. 이 벡터의 각 튜플은 키와 키에 대한 값으로 구성되어 있다. collect 메소드는 데이터를 모아서 HashMap을 포함한 여러 컬렉션 타입으로 만들어준다. 코드 예시는 다음과 같다.

```rust
use std::collections::HashMap;

let teams  = vec![String::from("블루"), String::from("옐로")];
let initial_scores = vec![10, 50];

let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();

```

해시맵의 키와 값 타입의 `<_, _>` 타입 애애노테이션을 사용할 수 있다. `<_, _>` 이 방식은 러스트에게 벡터의 타입 데이터를 통해 해시맵 내 키와 값의 타입을 유추하게 만든다.

### 해시맵과 소유권

i32와 같이 Copy 트레이트를 국현하는 타입은 값들이 해시맵으로 복사가 된다. 소유권 문제가 없다는 것이다. 반면 String 처럼 값을 소유하는 타입은 해시맵으로 그 값들의 소유권이 이전된다. 코드 예시를 보자.

```rust
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("블루");

let mut map = HashMap::new();
map.insert(field_name, field_value);
```

위 코드에서 field_name, field_value 두 변수는 인서트가 된 이후 부터 유효하지 않는다. 소유권이 이전되기 때문이다. 만약 소유권 이전을 하지 않기 위해 참조 값을 이용할 수도 있다. 단 참조 값을 사용할 때는 수명 문제에 주의해야한다. 참조한 값의 범위가 해시맵이 유효한 범위 내에 함께 유효한 범위로 존재해야만 참조값을 사용할 수 있다.

### 해시맵 내 값 접근하기

해시맵 안의 값을 읽어오려면 get 메서드를 이용하면 된다. 코드 예시는 다음과 같다.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("블루"), 10);
scores.insert(String::from("옐로"), 50);

let team_name = String::from("블루");
let score = scores.get(&team_name);
```

score는 블루 팀과 연관된 값을 가지게 된다. 결과값은 Some(&10)일 것입니다. score 변수의 결괏값은 some으로 감싸져 있다는 점이 특이한 점이다. 왜냐하면 get이 Option<&V>를 반환하기 때문이다. get 메서드가 반환하는 Option<&V> 값은 해시맵이 키는 가지지만 값이 존재하지 않을 경우를 대비하기 위함이다. 이에 따라 get 메서드는 해시맵 값이 없는 경우 none을 반환한다. 벡터나 스트링과 마찬가지로 해시맵의 키와 값 쌍을 for 루프를 통해 순회하여 확인할 수 있다.

### 해시맵 수정하기

해시맵에 많은 수의 키와 값을 저장할 수 있지만 하나의 키에 하나의 값만 저장할 수 있다. 이점은 파이썬의 딕셔너리와의 차이점이라 말할 수 있다. 해시맵에 있는 데이터를 수정해야할 때 이미 할당된 값에 대한 처리 문제가 발생한다. 기존의 값을 새값으로 교체하거나 기존의 값을 무시하거나, 기존의 값을 유지하고 새 값을 무시하거나 키에 값이 할당되어 있지 않은 경우에 값을 추가할 수 있다.

값을 덮어쓰는 방법은 같은 키에 다른 값을 새로 할당하는 것이다. 코드 예시는 다음과 같다.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("블루"), 10);
scores.insert(String::from("블루"), 25);

println!("{:?}", scores);

```

위 코드는 10을 할당한 블루 키에 새롭게 25를 할당하여 최종적으로 블루:25 라는 키 값 쌍 대응이 남는다. 즉 새로운 값이 기존의 값을 덮어쓴 것이다.
키에 값이 할당되어 있지 않은 경우에 값을 추가할 수도 있다. 이 경우가 대부분 많이 사용된다. 키에 값이 있는지 확인하는 방식은 entry 메서드를 이용하면 된다. entry 메서드는 리턴 값이 존재하는지 알려주는 Entry 열거자를 리턴한다. 이제 entry 메서드를 이용해 팀에 점수가 할당되어 있지 않으면 점수를 할당하는 방식의 코드 예시를 보자.

```rust

use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("블루"), 10);

scores.entry(String::from("옐로")).or_insert(50);
scores.entry(String::from("블루")).or_insert(50);

println!("{:?}", scores);
```

entry에 대한 or_insert 메서드는 해당 키가 존재할 경우 관련된 Entry 키에 대한 값을 반환하도록 정의되어 있다. 그렇지 않을 경우에는 파라미터로 주어진 값을 해당 키에 대한 새 값을 삽입하고 수정된 Entry에 대한 값을 반환한다. 이 방법은 우리가 직접 로직을 작성하는 것보다 훨씬 깔끔하고 값 대여 검사도 수행할 수 있다. 즉 소유권에 대한 문제가 발생하지 않는다.

기존 값에 따라 수정하는 방식도 존재한다. 해시맵의 키에 대한 값을 찾아서 예전 값에 기초하여 값을 갱신하는 것이다. 아래의 코드 예시를 보자.

```rust
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
```

dnlzhemsms 단어를 키로 사용하는 해쉬맵을 이용하여 해당 단어가 몇번이나 나왔는지를 유지하기 위해 값을 증가시켜 준다. 만일 어떤 단어를 처음 본 것이라면, 값 0을 삽입할 것이다. 여기서도 역참조가 사용되었는데 이는 기존의 word 값을 확인하고 따라가거나 변경해주어야 하기 때문이다. or_insert 메서드는 실제로는 해당 키에 대한 값의 가변 참조자 (&mut V)를 반환한다. 가변 참조자는 for 루프의 끝에서 스코프 밖으로 벗어나고, 따라서 모든 값들의 변경은 안전하며 빌림 규칙에 위배되지 않게 된다.

### 해시 함수

해시맵은 암호학적으로 강력한 해시 함수를 사용하여 서비스 거부(Dos) 공격을 방지할 수 있다. 성능과 보안의 오프셋은 고려해볼만한 가치가 있다. 만일 코드를 프로파일하여 기본 해쉬 함수가 목표에 대해 너무 느리다면, 다른 해쉬어(hasher) 를 특정하여 다른 함수로 바꿀 수 있다. 해쉬어는 BuildHasher 트레잇을 구현한 타입을 말한다.
